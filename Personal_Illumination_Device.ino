#include <Arduino.h>#include "BluefruitConfig.h"//#include <LowPower.h>#include <SoftwareSerial.h>#include <Adafruit_NeoPixel.h>#include <EEPROM.h>#include <Adafruit_CircuitPlayground.h>#include <Wire.h>#include <SPI.h>#include "visualizer.h"#include "candle.h"//** IO pins for the button, the NeoPixels, the light sensor and the microphone//** digitalconst int button1 = 4;const int lights = 17;//** analogconst int ldr = 5;const int mic = 4;const int pot = NULL;//** How many NeoPixels do we haveconst int pixels = 10;//** Modesconst int mode_flashlight = 1;const int mode_reading = 2;const int mode_sense = 3;const int mode_sleep_and_wake = 4;const int mode_countdown = 5;const int mode_visualizer = 6;const int mode_candles = 7;const int mode_count = 7;//** Default modeint mode = mode_visualizer;int oldmode = 0;//** current level of brightnessint brightness = 255;char sleepmode = 'O';//** These are used for debouncing the buttonint button;int button_last = 1;unsigned long button_last_time = 0;unsigned long button_delay = 20;//** For controlling the lightsAdafruit_NeoPixel strip;//** communicating through bluetoothAdafruit_BluefruitLE_UART ble(BLUEFRUIT_HWSERIAL_NAME, BLUEFRUIT_UART_MODE_PIN);void showMode() {  strip.clear();  strip.setPixelColor(mode - 1, 255,0,0);  strip.show();}//** the setup routine runs once when you turn on or press reset:void setup() {  Serial.begin(9600);    pinMode(button1, INPUT_PULLUP); //** Tell it to default to being positive  pinMode(lights, OUTPUT);  pinMode(ldr, INPUT);    //** Initialize the lights  strip = Adafruit_NeoPixel(pixels, lights, NEO_GRB + NEO_KHZ800);  strip.begin();  strip.show();    randomSeed(analogRead(UNCONNECTED_PIN));    button_last_time = millis();  showMode();      CircuitPlayground.begin();  CircuitPlayground.setBrightness(255);  CircuitPlayground.clearPixels();  // Initialize rolling average ranges (for visualizer)  uint8_t i;  for(i=0; i<BINS; i++) {    avgLo[i] = 0;    avgHi[i] = 255;  }  for(i=0; i<FRAMES; i++) {    memset(&lvl[i], 127, sizeof(lvl[i]));  }    ble.begin(VERBOSE_MODE);    /* Disable command echo from Bluefruit */  ble.echo(false);    ble.info();    ble.verbose(false);/** * Uncomment the code below the first time you load, so that it can set the name of the bluetooth device *   while (! ble.isConnected()) {      delay(500);  }  //** change the name of our bluetooth device. We dont have to do this everytime because its stored, but this is easy  ble.sendCommandCheckOK("AT+GAPDEVNAME=Personal Illumination Device"); */  //** now switch to data mode//  ble.println("+++\r\n");  }//** the loop routine runs over and over again forever:void loop() {  int button_read = digitalRead(button1);    //ble.update(); 	//** check to see if the button was changed (up or down, or noise) from the last time we checked  if (button_read != button_last) {        button_last_time = millis();  }  if ((millis() - button_last_time) > button_delay) {    // whatever the reading is at, it's been there for longer than the debounce    // delay, so take it as the actual current state:    // if the button state has changed:    if (button_read != button) {      button = button_read;      // only toggle the LED if the new button state is HIGH      if (button == 1) {        mode++;        if (mode > mode_count) mode = 1;        		    showMode();      }    }  }  // save the reading. Next time through the loop, it'll be the lastButtonState:  button_last = button_read;    //** now check the bluetooth serial port for commands  if (ble.available() > 0) {    Serial.println('command:');    if (ble.read() == 'M') {      mode = ble.parseInt();            switch (mode) {        case mode_flashlight:          brightness = ble.parseInt();          break;        case mode_reading:          brightness = ble.parseInt();          break;              case mode_sleep_and_wake:          sleepmode = ble.read();        ble.println("sleepmode: ");        ble.println(sleepmode);          break;      }      showMode();    }  }      int a;    switch(mode) {    case mode_flashlight:      int potread;            //** check if mode changed      if (oldmode != mode) {        //** initialize                oldmode = mode;      } else {        	for (a = 0;a < pixels;a++) {            strip.setPixelColor(a, brightness, brightness, brightness);      	}        strip.show();      }      break;    case mode_reading:      //** check if mode changed      if (oldmode != mode) {                oldmode = mode;      } else {        float green = brightness;        float blue = brightness;                green = green * .74;        blue = blue * .56;                Serial.println(green);        Serial.println(blue);                for (a = 0;a < pixels;a++) {            strip.setPixelColor(a, brightness, (int)green, (int)blue);      	}        strip.show();      }    	break;    case mode_sense:      int ldrread;            ldrread = analogRead(ldr);      ble.println(ldrread);            if (ldrread < 10 & ldrread > 2) {    	for (a = 0;a < pixels;a++) {          strip.setPixelColor(a, brightness, brightness, brightness);    	}      strip.show();      } else {    	for (a = 0;a < pixels;a++) {          strip.setPixelColor(a, 0, 0, 0);                    //** go into low power mode          //LowPower.idle(SLEEP_8S, ADC_OFF, TIMER4_OFF, TIMER3_OFF, TIMER1_OFF, TIMER0_OFF, SPI_OFF, TWI_OFF, USB_OFF);    	}      strip.show();      }      break;    case mode_sleep_and_wake:      /*if (oldmode != mode) {                oldmode = mode;*/        switch (sleepmode) {          case 'S':             	for (a = 0;a < pixels;a++) {           	  //** Warm color promotes sleep              strip.setPixelColor(a,64, 41, 0);          	}        	  strip.show();            break;          case 'W':          	for (a = 0;a < pixels;a++) {          	  //** colder color promotes wakefullness              strip.setPixelColor(a,0, 41, 64);              //strip.setPixelColor(a,41, 147, 255);          	}        	  strip.show();        	case 'O':          	for (a = 0;a < pixels;a++) {          	  //** off!              strip.setPixelColor(a,0, 0, 0);          	}        	  strip.show();      	            break;        }      //}    	break;    case mode_countdown:    	break;    case mode_visualizer:      visualizer();    	break;    case mode_candles:      int color;                  //** check if mode changed      if (oldmode != mode) {          set_color(255);          index_start = 255;          index_end = 255;          state = BRIGHT;        oldmode = mode;      } else {         candleloop();      }    	break;  }}void visualizer() {  uint16_t spectrum[32]; // FFT spectrum output buffer  CircuitPlayground.mic.fft(spectrum);  // spectrum[] is now raw FFT output, 32 bins.  // Remove noise and apply EQ levels  uint8_t  i, N;  uint16_t S;  for(i=0; i<32; i++) {    N = pgm_read_byte(&noise[i]);    if(spectrum[i] > N) { // Above noise threshold: scale & clip      S           = ((spectrum[i] - N) *                     (uint32_t)pgm_read_word(&binMul[i])) >> 8;      spectrum[i] = (S < 255) ? S : 255;    } else { // Below noise threshold: clip      spectrum[i] = 0;    }  }  // spectrum[] is now noise-filtered, scaled & clipped  // FFT output, in range 0-255, still 32 bins.  // Filter spectrum[] from 32 elements down to 10,  // make pretty colors out of it:  uint16_t sum, level;  uint8_t  j, minLvl, maxLvl, nBins, binNum, *data;  for(i=0; i<BINS; i++) { // For each output bin (and each pixel)...    data   = (uint8_t *)pgm_read_word(&binData[i]);    nBins  = pgm_read_byte(&data[0]); // Number of input bins to merge    binNum = pgm_read_byte(&data[1]); // Index of first input bin    data  += 2;    for(sum=0, j=0; j<nBins; j++) {      sum += spectrum[binNum++] * pgm_read_byte(&data[j]); // Total    }    sum /= pgm_read_word(&binDiv[i]);                      // Average    lvl[frameIdx][i] = sum;      // Save for rolling averages    minLvl = maxLvl = lvl[0][i]; // Get min and max range for bin    for(j=1; j<FRAMES; j++) {    // from prior stored frames      if(lvl[j][i] < minLvl)      minLvl = lvl[j][i];      else if(lvl[j][i] > maxLvl) maxLvl = lvl[j][i];    }    // minLvl and maxLvl indicate the extents of the FFT output for this    // bin over the past few frames, used for vertically scaling the output    // graph (so it looks interesting regardless of volume level).  If too    // close together though (e.g. at very low volume levels) the graph    // becomes super coarse and 'jumpy'...so keep some minimum distance    // between them (also lets the graph go to zero when no sound playing):    if((maxLvl - minLvl) < 23) {      maxLvl = (minLvl < (255-23)) ? minLvl + 23 : 255;    }    avgLo[i] = (avgLo[i] * 7 + minLvl) / 8; // Dampen min/max levels    avgHi[i] = (maxLvl >= avgHi[i]) ?       // (fake rolling averages)      (avgHi[i] *  3 + maxLvl) /  4 :       // Fast rise      (avgHi[i] * 31 + maxLvl) / 32;        // Slow decay    // Second fixed-point scale then 'stretches' each bin based on    // dynamic min/max levels to 0-256 range:    level = 1 + ((sum <= avgLo[i]) ? 0 :                 256L * (sum - avgLo[i]) / (long)(avgHi[i] - avgLo[i]));    // Clip output and convert to color:    if(level <= 255) {      uint8_t r = (pgm_read_byte(&reds[i])   * level) >> 8,              g = (pgm_read_byte(&greens[i]) * level) >> 8,              b = (pgm_read_byte(&blues[i])  * level) >> 8;      CircuitPlayground.strip.setPixelColor(i,        pgm_read_byte(&gamma8[r]),        pgm_read_byte(&gamma8[g]),        pgm_read_byte(&gamma8[b]));    } else { // level = 256, show white pixel OONTZ OONTZ      CircuitPlayground.strip.setPixelColor(i, 0x56587F);    }  }  CircuitPlayground.strip.show();  if(++frameIdx >= FRAMES) frameIdx = 0;}void set_color(byte index)  {    int a;        index = MAXVAL(MINVAL(index, INDEX_MAX), INDEX_BOTTOM);    if (index >= INDEX_MIN) {      for (a = 0;a < pixels;a++) {        strip.setPixelColor(a, index, (index * 3) / 8, 0);      }    }    else if (index < INDEX_MIN) {      for (a = 0;a < pixels;a++) {        strip.setPixelColor(a, index, (index * 3.25) / 8, 0);      }    }        strip.show();    return;  }  void candleloop()  {  unsigned long current_time;  current_time = millis();  switch (state)    {    case BRIGHT:      flicker_msecs = random(DOWN_MAX_MSECS - DOWN_MIN_MSECS) + DOWN_MIN_MSECS;      flicker_start = current_time;      index_start = index_end;      if ((index_start > INDEX_BOTTOM) &&          (random(100) < INDEX_BOTTOM_PERCENT))        index_end = random(index_start - INDEX_BOTTOM) + INDEX_BOTTOM;      else        index_end = random(index_start - INDEX_MIN) + INDEX_MIN;      state = DOWN;      break;    case DIM:      flicker_msecs = random(UP_MAX_MSECS - UP_MIN_MSECS) + UP_MIN_MSECS;      flicker_start = current_time;      index_start = index_end;      index_end = random(INDEX_MAX - index_start) + INDEX_MIN;      state = UP;      break;    case BRIGHT_HOLD:    case DIM_HOLD:      if (current_time >= (flicker_start + flicker_msecs))        state = (state == BRIGHT_HOLD) ? BRIGHT : DIM;      break;    case UP:    case DOWN:      if (current_time < (flicker_start + flicker_msecs))        set_color(index_start + ((index_end - index_start) * (((current_time - flicker_start) * 1.0) / flicker_msecs)));      else        {        set_color(index_end);        if (state == DOWN)          {          if (random(100) < DIM_HOLD_PERCENT)            {            flicker_start = current_time;            flicker_msecs = random(DIM_HOLD_MAX_MSECS - DIM_HOLD_MIN_MSECS) + DIM_HOLD_MIN_MSECS;            state = DIM_HOLD;            }          else            state = DIM;          }        else          {          if (random(100) < BRIGHT_HOLD_PERCENT)            {            flicker_start = current_time;            flicker_msecs = random(BRIGHT_HOLD_MAX_MSECS - BRIGHT_HOLD_MIN_MSECS) + BRIGHT_HOLD_MIN_MSECS;            state = BRIGHT_HOLD;            }          else            state = BRIGHT;          }        }      break;    }  return;  }